# Shadowmark ‚Äî Multimedia Data Security Project (2025)

This repository contains the full implementation and instructions for the **Multimedia Data Security** challenge (University of Trento, 2025).  
The goal is to design a **spread-spectrum watermarking system** in the **DCT domain**, complete with **embedding**, **detection**, **ROC computation**, and **attack evaluation**.

Group name: **shadowmark**

---

## üìÇ Project structure

| File | Description |
|------|--------------|
| **embedding.py** | Embeds a binary watermark using a DCT-based spread-spectrum method (multiplicative). Self-contained. |
| **detection_shadowmark.py** | Detects the watermark and computes the WPSNR. Includes the professor‚Äôs official WPSNR implementation and the final threshold `œÑ = 0.037798`. |
| **attacks.py** | Implements all allowed image attacks: JPEG compression, AWGN, Gaussian blur, median filter, resize, and sharpening. |
| **roc_threshold.py** | Computes the ROC curve on the 101-image dataset, finds the optimal threshold `œÑ`, and saves `roc.png`, `roc.pdf`, and `tau.json`. |
| **mark.npy** | The binary watermark (1024 bits). A dummy watermark can be generated if missing. |
| **roc.png / roc.pdf** | ROC plots automatically generated by `roc_threshold.py`. |
| **tau.json** | JSON file with the final ROC metrics (œÑ, AUC, FPR, TPR). |
| **attack_log.csv** | Log of valid attacks (presence = 0, WPSNR ‚â• 35 dB). |
| **requirements.txt** | List of dependencies. |
| **README.md** | This document. |

---

## ‚öôÔ∏è Setup

### 1. Clone or download the repository

```bash

git clone <repo-url>

cd project
```
### 2. Create and activate a Python virtual environment
On Windows (PowerShell)
```
PowerShellpython -m venv OFF_MDS_ENV

OFF_MDS_ENVScriptsActivate.ps1
```
On macOS / Linux / 
```
Git BashBashpython3 -m venv OFF_MDS_ENV

source OFF_MDS_ENV/bin/activate
```
### 3. Install dependencies
```Bash
pip install -r requirements.txt
```
üß© Step-by-step workflow
------------------------

### 0\. Verify environment

```
ls -la
python -V
python -c "import numpy, cv2, scipy; print('libs ok')"`
```
### 1\. Generate a watermark (if not provided)

```
python - <<'PY'
import numpy as np
np.save('mark.npy', (np.random.rand(1024) > 0.5).astype('uint8'))
print("Dummy mark.npy created")
PY`
```
### 2\. Embed the watermark

```
python - <<'PY'
from embedding import embedding
import cv2
wm = embedding("lena_grey.bmp", "mark.npy")
cv2.imwrite("shadowmark_lena_grey.bmp", wm)
print("Saved: shadowmark_lena_grey.bmp")
PY`
```
### 3\. Quick smoke test (optional)
```
python test_smoke.py
```
Expected:

-   TP self-sim ‚âà 1.0

-   TN sim ‚âà 0.0

-   Some attacks with WPSNR ‚â• 35 and sim < œÑ (valid destroyed images)

* * * * *

üìà ROC Curve and Threshold Estimation
-------------------------------------

To compute the ROC on the **101-image dataset** (`0000.bmp` -- `0100.bmp`):

1.  Place all 101 `.bmp` images inside a folder named `images/` within the project directory.

2.  Run the ROC script:
```
    python roc_threshold.py
```
3.  The script will automatically:

    -   process all images,

    -   compute the ROC curve,

    -   save `roc.png`, `roc.pdf`, and `tau.json`.

Example output:

`Found 101 images for ROC computation.
Processed 100/101 images...
ROC completed on 101 images.
AUC=0.858  tau=0.037798  @ FPR=0.069, TPR=0.855`

This threshold (`œÑ = 0.037798`) is already included in `detection_shadowmark.py`.

* * * * *

‚úÖ Detection Tests
-----------------

### 1\. Watermarked image (should detect)
```
python - <<'PY'
from detection_shadowmark import detection
p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey.bmp")
print("presence:", p, "wpsnr:", w)
PY
```
Expected: `presence = 1`, `WPSNR ‚âà 9999999`.

### 2\. Clean image (should NOT detect)
```
python - <<'PY'
from detection_shadowmark import detection
p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","lena_grey.bmp")
print("clean -> presence:", p, "wpsnr:", w)
PY
```
Expected: `presence = 0`.

### 3\. Destroyed image (WPSNR < 35 ‚Üí should NOT detect)
```
python - <<'PY'
import cv2
from attacks import attack_awgn
from detection_shadowmark import detection
wm = cv2.imread("shadowmark_lena_grey.bmp",0)
destroyed = attack_awgn(wm, sigma=30)
cv2.imwrite("shadowmark_lena_grey_destroyed.bmp", destroyed)
p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey_destroyed.bmp")
print("destroyed -> presence:", p, "wpsnr:", w)
PY
```
Expected: `presence = 0`, `WPSNR < 35`.

* * * * *

üî¨ Attack Validation on the 101-Image Dataset
---------------------------------------------

After computing the ROC curve (AUC = 0.858, œÑ = 0.037798), we validated the detection threshold\
on five random images from the 101-image dataset (`0000.bmp` -- `0100.bmp`).

Each image was watermarked and tested under the three main attack types:

| Attack | Avg WPSNR [dB] | Mean presence | Comment |
| --- | --- | --- | --- |
| AWGN œÉ = 14 | ‚âà 40.3 -- 40.4 | Variable (0 / 1) | Borderline, sometimes passes œÑ |
| Resize 0.55 | ‚âà 40 -- 46 | Mostly 1 | Watermark still detected |
| Resize 0.6 + JPEG 70 | ‚âà 36 -- 47 | Mostly 0 | ‚úÖ Valid attack (WPSNR ‚â• 35, presence = 0) |

The **resize 0.6 + JPEG 70** combination consistently removes the watermark while preserving\
good image quality (WPSNR ‚â• 35 dB) across multiple random samples.

**Examples of valid destroyed images:**

`shadowmark_lena_grey_resize_scale0.6__jpeg_qf70.bmp
shadowmark_0097_resize06_jpeg70.bmp
shadowmark_0005_resize06_jpeg70.bmp
shadowmark_0033_resize06_jpeg70.bmp`

**Conclusion:**\
The final threshold œÑ = 0.037798 correctly avoids false positives on clean or destroyed images,\
while detecting all valid watermarks in unaltered or lightly attacked cases.\
The *resize 0.6 + JPEG 70* attack satisfies the official challenge condition\
(**presence = 0 and WPSNR ‚â• 35 dB**) on the extended dataset.
The chosen detection threshold œÑ = 0.037798 correctly avoids false positives on clean or destroyed
images, and successfully detects watermarks in all unaltered or lightly attacked cases.
The attack *resize 0.6 + JPEG 70* meets the official challenge condition  
(**presence = 0 and WPSNR ‚â• 35 dB**) on the extended dataset.
