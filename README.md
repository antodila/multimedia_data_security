# Shadowmark ‚Äî Multimedia Data Security Project (2025)

This repository contains the full implementation and instructions for the **Multimedia Data Security** challenge (University of Trento, 2025).  
The goal is to design a **spread-spectrum watermarking system** in the **DCT domain**, complete with **embedding**, **detection**, **ROC computation**, and **attack evaluation**.

Group name: **shadowmark**

---

## üìÇ Project structure

| File | Description |
|------|--------------|
| **embedding.py** | Self-contained embedding script. Public API: `embedding(input_image_path, watermark_path_or_array) ‚Üí np.uint8`. Implements multiplicative DCT-based spread spectrum embedding. |
| **detection_shadowmark.py** | Self-contained watermark detector. Public API: `detection(original_img_path, watermarked_img_path, test_img_path) ‚Üí (presence:int, wpsnr:float)`. Includes the **professor‚Äôs WPSNR function** inline and uses a **residual ratio** feature for robustness. |
| **attacks.py** | Implements all permitted attacks (JPEG compression, AWGN, Gaussian blur, median filtering, resize, and sharpening). |
| **roc_threshold.py** | Computes the ROC curve using similarity scores, selects `tau` with FPR ‚â§ 0.1, and saves `roc.png`, `roc.pdf`, and `tau.json`. |
| **test_smoke.py** | Quick sanity tests (TP, TN, and several attacks) for development only. |
| **mark.npy** | Watermark file (1024 bits). A dummy can be generated if the official one is not provided. |
| **lena_grey.bmp** | Sample grayscale test image (512√ó512). |
| **roc.png / roc.pdf** | ROC plots automatically generated by `roc_threshold.py`. |
| **tau.json** | JSON file containing ROC metrics (`tau`, AUC, FPR, TPR). |
| **attack_log.csv** | Optional log file containing valid destroyed images (WPSNR ‚â• 35 dB and presence = 0). |
| **README.md** | This document. |

---

## ‚öôÔ∏è Setup

### 1. Clone or download the repository
```bash
git clone <repo-url>
cd project
2. Create and activate a Python virtual environment
On Windows (PowerShell)
powershell
Copia codice
python -m venv OFF_MDS_ENV
OFF_MDS_ENV\Scripts\Activate.ps1
On macOS / Linux / Git Bash
bash
Copia codice
python3 -m venv OFF_MDS_ENV
source OFF_MDS_ENV/bin/activate
3. Install dependencies
bash
Copia codice
pip install numpy scipy opencv-python scikit-learn matplotlib pandas
üß© Step-by-step workflow
0. Verify environment and files
bash
Copia codice
pwd
ls -la
python -V
python -c "import numpy, cv2, scipy; print('libs ok')"
1. Generate a watermark (if not provided)
bash
Copia codice
python - <<'PY'
import numpy as np
np.save('mark.npy', (np.random.rand(1024) > 0.5).astype('uint8'))
print("Dummy mark.npy created")
PY
2. Embed the watermark
bash
Copia codice
python - <<'PY'
from embedding import embedding
import cv2
wm = embedding("lena_grey.bmp", "mark.npy")
cv2.imwrite("shadowmark_lena_grey.bmp", wm)
print("Saved: shadowmark_lena_grey.bmp")
PY
Expected output:

makefile
Copia codice
Saved: shadowmark_lena_grey.bmp
3. Run smoke tests (TP / TN / attacks)
bash
Copia codice
python test_smoke.py
Expected:

TP self-sim ‚âà 1.0

TN sim ‚âà 0.0

Attacks: some with WPSNR ‚â• 35 and sim < tau (valid destroyed images)

4. Compute ROC curve and find œÑ
bash
Copia codice
python roc_threshold.py
This generates:

roc.png and roc.pdf ‚Äî ROC plot

tau.json ‚Äî threshold and statistics

Example output:

ini
Copia codice
AUC=1.000  tau=0.307841  @ FPR=0.000, TPR=1.000
Then, open detection_shadowmark.py and set this œÑ:

python
Copia codice
tau = 0.307841
5. Check detection correctness
5.1 Watermarked vs itself
bash
Copia codice
python - <<'PY'
from detection_shadowmark import detection
p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey.bmp")
print("presence:", p, "wpsnr:", w)
PY
Expected: presence = 1, wpsnr ‚âà 9999999.0.

5.2 Valid attack (e.g., resize)
bash
Copia codice
python - <<'PY'
import cv2
from attacks import attack_resize
from detection_shadowmark import detection
wm = cv2.imread("shadowmark_lena_grey.bmp", 0)
att = attack_resize(wm, scale=0.6)
cv2.imwrite("shadowmark_lena_grey_resize06.bmp", att)
p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey_resize06.bmp")
print("resize06 -> presence:", p, "wpsnr:", w)
PY
Expected: presence = 0, WPSNR ‚â• 35 dB.

6. Negative checks (professor‚Äôs requirements)
6.1 Clean image ‚Üí must not detect watermark
bash
Copia codice
python - <<'PY'
from detection_shadowmark import detection
p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","lena_grey.bmp")
print("clean -> presence:", p, "wpsnr:", w)
PY
Expected: presence = 0.

6.2 Destroyed image (WPSNR < 35) ‚Üí must not detect
bash
Copia codice
python - <<'PY'
import cv2
from attacks import attack_awgn
from detection_shadowmark import detection
wm = cv2.imread("shadowmark_lena_grey.bmp",0)
destroyed = attack_awgn(wm, sigma=30)
cv2.imwrite("shadowmark_lena_grey_destroyed.bmp", destroyed)
p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey_destroyed.bmp")
print("destroyed -> presence:", p, "wpsnr:", w)
PY
Expected: presence = 0, WPSNR < 35.

7. Timing (must be < 5 seconds)
bash
Copia codice
python - <<'PY'
import time
from detection_shadowmark import detection
t0=time.time()
_ = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey_resize06.bmp")
print("elapsed:", time.time()-t0)
PY
8. Attack log (optional)
Append entries of valid attacks (WPSNR ‚â• 35, presence=0):

sql
Copia codice
Image,Group,WPSNR,Attack,Params,OutputFile
lena_grey.bmp,shadowmark,47.42,resize,scale=0.6,shadowmark_lena_grey_resize06.bmp
lena_grey.bmp,shadowmark,47.52,awgn,sigma=6,shadowmark_lena_grey_awgn6.bmp