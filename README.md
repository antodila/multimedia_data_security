# Shadowmark ‚Äî Multimedia Data Security Project (2025)

This repository contains the full implementation and instructions for the **Multimedia Data Security** challenge (University of Trento, 2025).  
The goal is to design a **spread-spectrum watermarking system** in the **DCT domain**, complete with **embedding**, **detection**, **ROC computation**, and **attack evaluation**.

Group name: **shadowmark**

---

## üìÇ Project structure

| File | Description |
|------|--------------|
| **embedding.py** | Self-contained embedding script. Public API: `embedding(input_image_path, watermark_path_or_array) ‚Üí np.uint8`. Implements multiplicative DCT-based spread spectrum embedding. |
| **detection_shadowmark.py** | Self-contained watermark detector. Public API: `detection(original_img_path, watermarked_img_path, test_img_path) ‚Üí (presence:int, wpsnr:float)`. Includes the **professor‚Äôs WPSNR function** inline and uses a **residual ratio** feature for robustness. |
| **attacks.py** | Implements all permitted attacks (JPEG compression, AWGN, Gaussian blur, median filtering, resize, and sharpening). |
| **roc_threshold.py** | Computes the ROC curve using similarity scores, selects `tau` with FPR ‚â§ 0.1, and saves `roc.png`, `roc.pdf`, and `tau.json`. |
| **test_smoke.py** | Quick sanity tests (TP, TN, and several attacks) for development only. |
| **mark.npy** | Watermark file (1024 bits). A dummy can be generated if the official one is not provided. |
| **lena_grey.bmp** | Sample grayscale test image (512√ó512). |
| **roc.png / roc.pdf** | ROC plots automatically generated by `roc_threshold.py`. |
| **tau.json** | JSON file containing ROC metrics (`tau`, AUC, FPR, TPR). |
| **attack_log.csv** | Optional log file containing valid destroyed images (WPSNR ‚â• 35 dB and presence = 0). |
| **README.md** | This document. |

---

## ‚öôÔ∏è Setup

### 1. Clone or download the repository

```bash

git clone <repo-url>

cd project
```
### 2. Create and activate a Python virtual environment
On Windows (PowerShell)
```PowerShellpython -m venv OFF_MDS_ENV

OFF_MDS_ENVScriptsActivate.ps1
```
On macOS / Linux / 
```Git BashBashpython3 -m venv OFF_MDS_ENV

source OFF_MDS_ENV/bin/activate
```
### 3. Install dependenciesBashpip install numpy scipy opencv-python scikit-learn matplotlib pandas

üß© Step-by-step workflow0. Verify environment and filesBashpwd
```
ls -la

python -V

python -c "import numpy, cv2, scipy; print('libs ok')"
```
1. Generate a watermark (if not provided)
```Bash
python - <<'PY'

import numpy as np

np.save('mark.npy', (np.random.rand(1024) > 0.5).astype('uint8'))

print("Dummy mark.npy created")

PY
```
2. Embed the watermark
```Bash
python - <<'PY'

from embedding import embedding

import cv2

wm = embedding("lena_grey.bmp", "mark.npy")

cv2.imwrite("shadowmark_lena_grey.bmp", wm)

print("Saved: shadowmark_lena_grey.bmp")

PY
```
Expected output:ShellSaved: shadowmark_lena_grey.bmp

3. Run smoke tests (TP / TN / attacks)
```Bash
python test_smoke.py
```
Expected:ShellTP self-sim ‚âà 1.0

TN sim ‚âà 0.0

Attacks: some with WPSNR ‚â• 35 and sim < tau (valid destroyed images)

4. Compute ROC curve and find $tau$
```Bash
python roc_threshold.py
```
This generates:roc.png and roc.pdf ‚Äî ROC plottau.json ‚Äî threshold and statisticsExample output:Ini, TOMLAUC=1.000  tau=0.307841  @ FPR=0.000, TPR=1.000

Then, open detection_shadowmark.py and set this $tau$:Pythontau = 0.307841

5. Check detection correctness
5.1 Watermarked vs itself
```Bash
python - <<'PY'

from detection_shadowmark import detection

p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey.bmp")

print("presence:", p, "wpsnr:", w)

PY
```
Expected: presence = 1, wpsnr ‚âà 9999999.0.
5.2 Valid attack (e.g., resize)
```Bash
python - <<'PY'

import cv2

from attacks import attack_resize

from detection_shadowmark import detection

wm = cv2.imread("shadowmark_lena_grey.bmp", 0)

att = attack_resize(wm, scale=0.6)

cv2.imwrite("shadowmark_lena_grey_resize06.bmp", att)

p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey_resize06.bmp")

print("resize06 -> presence:", p, "wpsnr:", w)

PY
```
Expected: presence = 0, WPSNR ‚â• 35 dB.
6. Negative checks (professor‚Äôs requirements)
6.1 Clean image ‚Üí must not detect watermark
```Bash
python - <<'PY'

from detection_shadowmark import detection

p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","lena_grey.bmp")

print("clean -> presence:", p, "wpsnr:", w)

PY
```
Expected: presence = 0.
6.2 Destroyed image (WPSNR < 35) ‚Üí must not detect
```Bash
python - <<'PY'

import cv2

from attacks import attack_awgn

from detection_shadowmark import detection

wm = cv2.imread("shadowmark_lena_grey.bmp",0)

destroyed = attack_awgn(wm, sigma=30)

cv2.imwrite("shadowmark_lena_grey_destroyed.bmp", destroyed)

p,w = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey_destroyed.bmp")

print("destroyed -> presence:", p, "wpsnr:", w)

PY
```
Expected: presence = 0, WPSNR < 35.
7. Timing (must be < 5 seconds)
```Bash
python - <<'PY'

import time

from detection_shadowmark import detection

t0=time.time()

_ = detection("lena_grey.bmp","shadowmark_lena_grey.bmp","shadowmark_lena_grey_resize06.bmp")

print("elapsed:", time.time()-t0)

PY
```
8. Attack log (optional)Append entries of valid attacks (WPSNR $ge$ 35, presence=0):
```Snippet di codiceImage,Group,WPSNR,Attack,Params,OutputFile

lena_grey.bmp,shadowmark,47.42,resize,scale=0.6,shadowmark_lena_grey_resize06.bmp

lena_grey.bmp,shadowmark,47.52,awgn,sigma=6,shadowmark_lena_grey_awgn6.bmp
```

## üî¨ Attack Validation on the 101-Image Dataset

Download the images that the teacher send, and add in a folder onto the project ones. After computing the ROC curve (AUC = 0.858, œÑ = 0.037798), we validated the detection threshold
on five random images from the 101-image dataset (`0000.bmp` ‚Äì `0100.bmp`).

Each image was watermarked and tested under the three candidate attacks previously identified
from the grid search:

| Attack | Avg WPSNR [dB] | Mean presence | Comment |
|:--------|:---------------:|:--------------:|:---------|
| AWGN œÉ = 14 | ‚âà 40.3 ‚Äì 40.4 | Variable (0 / 1) | Borderline, sometimes passes œÑ |
| Resize 0.55 | ‚âà 40 ‚Äì 46 | Mostly 1 | Watermark still detected |
| Resize 0.6 + JPEG 70 | ‚âà 36 ‚Äì 47 | Mostly 0 | ‚úÖ Valid attack (WPSNR ‚â• 35, presence = 0) |

The **resize 0.6 + JPEG 70** combination consistently removes the watermark while preserving
acceptable image quality (WPSNR ‚â• 35 dB) across multiple random samples.

---

**Valid destroyed image examples**

shadowmark_lena_grey_resize_scale0.6__jpeg_qf70.bmp
shadowmark_0097_resize06_jpeg70.bmp
shadowmark_0005_resize06_jpeg70.bmp
shadowmark_0033_resize06_jpeg70.bmp

---

**Conclusion:**  
The chosen detection threshold œÑ = 0.037798 correctly avoids false positives on clean or destroyed
images, and successfully detects watermarks in all unaltered or lightly attacked cases.
The attack *resize 0.6 + JPEG 70* meets the official challenge condition  
(**presence = 0 and WPSNR ‚â• 35 dB**) on the extended dataset.